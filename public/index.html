<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Tracking</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
        #videos {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        video {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="my-4 text-center">Real-Time Tracking Application</h1>
        <div class="form-inline my-4 justify-content-center">
            <label for="username" class="mr-2">Username:</label>
            <input type="text" class="form-control mr-2" id="username" name="username">
            <button class="btn btn-primary" id="connectButton">Connect</button>
        </div>
        <div id="accelerometerData">
            <h3>Accelerometer Data</h3>
            <p>X: <span id="accelX">0</span></p>
            <p>Y: <span id="accelY">0</span></p>
            <p>Z: <span id="accelZ">0</span></p>
        </div>
        <div id="map" class="mb-4"></div>
        <div id="userList">
            <h2 class="my-4">Connected Users</h2>
            <ul id="users" class="list-group"></ul>
        </div>
        <div id="videos" class="row">
            <div class="col-md-6">
                <h3>Your Camera</h3>
                <video id="localVideo" class="border" autoplay muted></video>
            </div>
            <div class="col-md-6">
                <h3>Selected User's Camera</h3>
                <video id="remoteVideo" class="border" autoplay></video>
            </div>
        </div>
        <button id="requestMotionPermissionButton" class="btn btn-primary">Enable Motion Sensors</button>
    </div>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="js/main.js"></script>
    <script>
        let map, userMarker, userId, isConnected = false;
        const markers = {};
        const socket = new WebSocket('wss://nohan.lebreton.caen.mds-project.fr');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const accelX = document.getElementById('accelX');
        const accelY = document.getElementById('accelY');
        const accelZ = document.getElementById('accelZ');
        let localStream;
        let peerConnection;

        function initMap() {
            map = L.map('map').setView([51.505, -0.09], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            document.getElementById('connectButton').addEventListener('click', () => {
                const username = document.getElementById('username').value.trim();
                if (username !== '') {
                    if (!isConnected) {
                        userId = generateId();
                        connect(username);
                    } else {
                        disconnect();
                    }
                } else {
                    alert('Please enter a username.');
                }
            });

            document.getElementById('username').addEventListener('keydown', event => {
                if (event.key === 'Enter') {
                    document.getElementById('connectButton').click();
                }
            });

            document.getElementById('requestMotionPermissionButton').addEventListener('click', requestMotionPermission);
        }

        async function connect(username) {
            isConnected = true;
            document.getElementById('connectButton').innerText = 'Disconnect';

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true });
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices.', error);
                alert('Error accessing media devices.');
                return;
            }

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(position => {
                    if (!isConnected) return; // Check if still connected
                    const { latitude, longitude } = position.coords;
                    const pos = [latitude, longitude];

                    if (!userMarker) {
                        userMarker = L.marker(pos).addTo(map).bindPopup(`Your Position (${username})`).openPopup();
                    } else {
                        userMarker.setLatLng(pos);
                    }

                    map.setView(pos);
                    socket.send(JSON.stringify({ type: 'user', id: userId, username, position: { latitude, longitude } }));
                });
            } else {
                alert("Geolocation is not supported by this browser.");
            }

            // Start Accelerometer
            requestMotionPermission();
        }

        function disconnect() {
            isConnected = false;
            document.getElementById('connectButton').innerText = 'Connect';
            if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
            }
            socket.send(JSON.stringify({ type: 'user', id: userId, disconnect: true }));
            // Remove user markers from the map
            Object.keys(markers).forEach(id => {
                if (markers[id]) {
                    map.removeLayer(markers[id]);
                    delete markers[id];
                }
            });
            // Clear the user list
            document.getElementById('users').innerHTML = '';
            localVideo.srcObject = null;
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
        }

        socket.onmessage = event => {
            if (!isConnected) return; // Check if still connected

            const message = JSON.parse(event.data);
            if (message.type === 'users') {
                const users = message.data;
                const connectedUsers = users.filter(user => !user.disconnect); // Filter connected users

                // Update the map markers
                connectedUsers.forEach(user => {
                    if (!markers[user.id]) {
                        markers[user.id] = L.marker([user.position.latitude, user.position.longitude]).addTo(map).bindPopup(`${user.username}'s Position`);
                    } else {
                        markers[user.id].setLatLng([user.position.latitude, user.position.longitude]);
                    }
                });

                // Remove markers of disconnected users
                Object.keys(markers).forEach(id => {
                    if (!connectedUsers.find(user => user.id === id)) {
                        map.removeLayer(markers[id]);
                        delete markers[id];
                    }
                });

                // Update the user list
                const userList = document.getElementById('users');
                userList.innerHTML = '';
                connectedUsers.forEach(user => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${user.username} connected at ${user.connectedAt}`;
                    const viewButton = document.createElement('button');
                    viewButton.textContent = 'View Camera';
                    viewButton.addEventListener('click', () => {
                        selectUser(user.id);
                    });
                    listItem.appendChild(viewButton);
                    userList.appendChild(listItem);
                });
            } else if (message.type === 'signal') {
                handleSignal(message);
            }
        };

        async function selectUser(id) {
            console.log(`Selecting user ${id}`);
            if (peerConnection) {
                peerConnection.close();
            }

            peerConnection = createPeerConnection(id);

            // Add local stream tracks to peer connection
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // Create offer and send to selected user
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            socket.send(JSON.stringify({
                type: 'signal',
                id: userId,
                target: id,
                offer: peerConnection.localDescription
            }));
        }

        function handleSignal(message) {
            const { id, target, offer, answer, candidate } = message;

            if (target === userId) {
                if (offer) {
                    console.log(`Received offer from ${id}`);
                    peerConnection = createPeerConnection(id);

                    peerConnection.setRemoteDescription(new RTCSessionDescription(offer))
                        .then(() => peerConnection.createAnswer())
                        .then(answer => peerConnection.setLocalDescription(answer))
                        .then(() => {
                            socket.send(JSON.stringify({
                                type: 'signal',
                                id: userId,
                                target: id,
                                answer: peerConnection.localDescription
                            }));
                        });
                } else if (answer) {
                    console.log(`Received answer from ${id}`);
                    peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                } else if (candidate) {
                    console.log(`Received candidate from ${id}`);
                    peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
            }
        }

        function createPeerConnection(id) {
            console.log(`Creating peer connection with ${id}`);
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            };
            const peerConnection = new RTCPeerConnection(config);

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    socket.send(JSON.stringify({
                        type: 'signal',
                        id: userId,
                        target: id,
                        candidate: event.candidate
                    }));
                    console.log(`Sending candidate to ${id}`);
                }
            };

            peerConnection.ontrack = event => {
                console.log('Received remote stream');
                remoteVideo.srcObject = event.streams[0];
            };

            return peerConnection;
        }

        function generateId() {
            return '_' + Math.random().toString(36).substr(2, 9);
        }

        window.onload = initMap;

        // Function to start the accelerometer
        function startAccelerometer() {
            if ('Accelerometer' in window) {
                const accelerometer = new Accelerometer({ frequency: 60 });
                accelerometer.addEventListener('reading', () => {
                    accelX.textContent = accelerometer.x.toFixed(2);
                    accelY.textContent = accelerometer.y.toFixed(2);
                    accelZ.textContent = accelerometer.z.toFixed(2);

                    if (isConnected) {
                        socket.send(JSON.stringify({
                            type: 'accelerometer',
                            id: userId,
                            data: {
                                x: accelerometer.x,
                                y: accelerometer.y,
                                z: accelerometer.z
                            }
                        }));
                    }
                });
                accelerometer.start();
            } else {
                console.error('Accelerometer not supported');
            }
        }

        // Function to request motion permission
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', (event) => {
                                accelX.textContent = event.accelerationIncludingGravity.x.toFixed(2);
                                accelY.textContent = event.accelerationIncludingGravity.y.toFixed(2);
                                accelZ.textContent = event.accelerationIncludingGravity.z.toFixed(2);

                                if (isConnected) {
                                    socket.send(JSON.stringify({
                                        type: 'accelerometer',
                                        id: userId,
                                        data: {
                                            x: event.accelerationIncludingGravity.x,
                                            y: event.accelerationIncludingGravity.y,
                                            z: event.accelerationIncludingGravity.z
                                        }
                                    }));
                                }
                            });
                        } else {
                            alert('Permission to access device motion was denied.');
                        }
                    })
                    .catch(console.error);
            } else {
                startAccelerometer(); // For browsers that don't require permission
            }
        }
    </script>
</body>
</html>

               
